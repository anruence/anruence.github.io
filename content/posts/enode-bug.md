---
title: enode错误排查历程
date: 2020-11-14 19:21:57
tags:
- issues
categories:
- enode
---

## enode的整体线程模型的思考
技术选型采用了vert.x 实现异步反应式JDBC客户端，同时代码实现中存在大量的异步操作
如果不使用协程，会涉及到频繁的线程切换。由于C#中有好用的async/await语法
Java的实现要如何改造才好呢？这是个困扰我好久的问题，目前性能上不去我觉得和这个也有很大原因

另外，接口的实现，提供一个异步化的接口暴露出去是否合适，接口的设计需要优化，对应用中暴露的接口不应该出现Future之类的字样。

现有mailbox的实现，为了支持聚合根的批量提交消息，实现的有点复杂，我在想着能不能换成akka实现，同时使用disruptor
目前的策略，一个聚合根有一个command mailbox和一个 event mailbox，多个聚合根公用一批event commit mailbox，如果把这部分逻辑交给akka托管

## 消息返回类型选择
什么时候返回
三种模式
- command消息发送完成
- command消息执行完成
- event消息消费完成

## 为什么一定要是顺序消息
对同一个聚合根的修改要路由到同一个队列中，如果rebalance或者不在同一个队列，会有并发冲突问题

## 间接模拟 async/await 语法糖
Java 中模拟async的执行时
如果是循环执行一个异步方法时，还要保证执行的顺序，这时可能就要借住递归的方式来实现

## 并发重复创建同一个聚合
两种情况
1.同一个命令并发执行创建同一个聚合根
在第一个命令执行未完成时，会直接抛出重复命令注册异常，如果第一个命令执行完成，则都幂等返回创建成功

2.不同命令并发创建同一个聚合根
开启批量提交时，检测出同时修改时，会抛出重复领域事件异常，错误返回

会出现一个创建成功，一个创建失败

## published_version表的作用
记录对事件消息的消费进度

## 命令消息的顺序执行机制
command mailbox，类似actor，保证顺序消费
